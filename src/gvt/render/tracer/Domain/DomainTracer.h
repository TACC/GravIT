/* =======================================================================================
   This file is released as part of GraviT - scalable, platform independent ray tracing
   tacc.github.io/GraviT

   Copyright 2013-2015 Texas Advanced Computing Center, The University of Texas at Austin
   All rights reserved.

   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
   except in compliance with the License.
   A copy of the License is included with this software in the file LICENSE.
   If your copy does not contain the License, you may obtain a copy of the License at:

       http://opensource.org/licenses/BSD-3-Clause

   Unless required by applicable law or agreed to in writing, software distributed under
   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
   KIND, either express or implied.
   See the License for the specific language governing permissions and limitations under
   limitations under the License.

   GraviT is funded in part by the US National Science Foundation under awards ACI-1339863,
   ACI-1339881 and ACI-1339840
   ======================================================================================= */

#ifndef GVT_RENDER_DOMAINTRACER
#define GVT_RENDER_DOMAINTRACER

#include <gvt/render/tracer/RayTracer.h>
#include <mutex>
#include <set>

namespace gvt {
namespace render {

/**
 * \brief Ray tracer scheduling using domain decomposition strategy
 *
 * The domain decomposition strategy assumes that certain data domains are only available in some of the computing nodes
 * thus rays need to be sent between them to compute their contribution. If the scheduler is used in a stand-alone node
 * it behaves as the Image Decomposition scheduler.
 *
 * The scheduler requires a user defined message type call SendRayList to encapsulate the rays sent among the nodes.
 * @see SendRayList
 *
 */
class DomainTracer : public gvt::render::RayTracer {
private:
protected:
  gvt::core::Map<int, unsigned> remote;        /**< Maps instances ids to their remote nodes */
  gvt::core::Map<int, bool> instances_in_node; /**< Determines if an instance (mesh) is available in the current node */

  std::shared_ptr<comm::vote::vote> v;        /**< Voting procedure */
  volatile bool _GlobalFrameFinished = false; /**< Communicates the result of the voting to the scheduler */

public:
  DomainTracer(std::shared_ptr<gvt::render::data::scene::gvtCameraBase> cam,
               std::shared_ptr<gvt::render::composite::ImageComposite> img);
  ~DomainTracer();
  /**
   * \brief Domain decomposition implementatiom
   *
   * Determines the highest queue (highest ray count) and schedules it. If there are rays in instance queues that are
   * only available in remote nodes, it encapsulates the queue in a send ray list message and delivers the message to
   * the communicator to be sent.
   *
   * At the end invokes the Image Composition procedure that computes the final image buffer.
   *
   * @method operator
   */
  void operator()();
  /**
   * \brief Filters all the rays generated by the camera.
   *
   * It moves the rays to queue of first instance intersection if that instance is available in the compute node,
   * otherwize drops the ray.
   *
   * @method processRaysAndDrop
   * @param  rays               [description]
   */
  void processRaysAndDrop(gvt::render::actor::RayVector &rays);
  /**
   * \brief Processes the ray returned by the adapter
   *
   * Sorts the arrays into there respective instance queues or computes their contribution to the final image by
   * accumulating locally.
   *
   *
   */
  void processRays(gvt::render::actor::RayVector &rays, const int src = -1, const int dst = -1);
  /**
   * Process incomming user messages, in this case SendRayList. After extracting the ray queue invokes processRays to
   * place them in the correct instance queue.
   *
   * Any other user message is passed to the parents method, to allow easy extension.
   *
   * @method MessageManager
   * @param  msg            Raw user message received by the communicatior
   * @return                true if the message was processed successfully
   */
  bool MessageManager(std::shared_ptr<gvt::comm::Message> msg);

  /**
   * Checks if there is not more work in the local queues and if the communicator has no more messages to deliver
   * @method isDone
   * @return true if no more work
   */
  bool isDone();
  /**
   * Checks if there is not more work in the local queues and if the communicator has no more messages to deliver
   * @method isDone
   * @return true if more work available
   */
  bool hasWork();
  /**
   * Set BVH and instances mapping
   *
   * @method resetBVH
   */
  void resetBVH();

  /**
   * \brief Check if an instance data is available in node
   * @method isInNode
   * @param  i        Instance internal id
   * @return          True if available
   */
  inline bool isInNode(const int &i) { return instances_in_node[i]; }

  /**
   * \brief Pick a remote node that contains the data for a given instance
   * @method pickNode
   * @param  i        Instance internal id
   * @return          Remote node id
   */
  inline int pickNode(const int &i) { return remote[i]; }

  /**
   * \brief Static method that allows the voting procedure to invoke the schedule isDone
   * @method areWeDone
   * @return true if no more work available
   */
  static bool areWeDone();

  /**
   * Static method used by the voting procedure to set the agreement value in the scheduler
   * @method Done
   * @param  bool [description]
   */
  static void Done(bool);

  /**
   * \brief Allows the static voting procedure to set the communication flag to the scheduler
   * \param v Value of the voting result (true if all agree that the work is finished)
   */
  void inline setGlobalFrameFinished(bool v) { _GlobalFrameFinished = v; }
  /**
   * Get the current agreement value for all the nodes
   * @method getGlobalFrameFinished
   * @return Current agreement value
   */
  bool inline getGlobalFrameFinished() { return _GlobalFrameFinished; }
};
}; // namespace render
}; // namespace gvt

#endif /*GVT_RENDER_DOMAINTRACER*/
